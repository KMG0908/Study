### Insertion Sort(삽입 정렬)
#### 개념
* 정렬되어 있는 부분집합에 정렬할 새로운 원소의 위치를 삽입하는 방식
* 과정
  * 정렬할 자료를 두 개의 부분집합 S와 U로 가정
    부분집합 S : 정렬된 앞 부분의 원소들
    부분집합 U : 아직 정렬되지 않은 나머지 원소들
  1. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입한다.
  2. 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 된다.
  3. 부분집합 U가 공집합이 되면 정렬이 완성된다.
  
#### 코드
```java
public class InsertionSort {
    public static void sort(int list[]) {
        final int SIZE = list.length;
		
        for(int i=1; i<SIZE; i++) {	// 정렬되지 않은 집합
            int temp = list[i];		// 정렬되어야 하는 원소
			
            for(int j=0; j<i; j++) {// 정렬된 집합
                if(temp < list[j]) {
                    for(int k=i-1; k>=j; k--) {	// 정렬된 집합의 맨 뒤부터 삽입지점까지 뒤로 민다
                        list[k+1] = list[k];
                    }
                    list[j] = temp;	// 삽입지점에 원소 넣기
                    break;
                }
            }
        }
    }
}
```

#### 특징
* 장점
  * 안정한 정렬 방법
  * 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
  * 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
* 단점
  * 비교적 많은 레코드들의 이동을 포함한다.
  * 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.
    
#### 시간 복잡도
##### 최선의 경우
* 비교 횟수
  * 이동 없이 1번의 비교만 이루어진다.
  * 외부 루프: (n-1)번
* Best T(n) = **O(n)**
##### 최악의 경우(입력 자료가 역순일 경우)
* 비교 횟수
  * 외부 루프 안의 각 반복마다 i번의 비교 수행
  * 외부 루프: (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n<sup>2</sup>)
* 교환 횟수
  * 외부 루프의 각 단계마다 (i+2)번의 이동 발생
  * n(n-1)/2 + 2(n-1) = (n<sup>2</sup>+3n-4)/2 = O(n<sup>2</sup>)
* Worst T(n) = **O(n<sup>2</sup>)**


> 본 글은 https://medium.com/@joongwon/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88-805391cb088e 과 https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html 를 바탕으로 작성되었습니다.
